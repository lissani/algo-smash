# 코테에서의 자료구조 선택

# 🧠 문제 → 자료구조 바로 떠올리는 연습법

## 0️⃣ 먼저 이 질문부터 자동으로 하자 (습관)

문제 읽으면서 **3초 안에** 이거 체크 👇

1. **순서 중요?**
2. **중복 허용?**
3. **최댓값/최솟값 계속 필요?**
4. **탐색이 많아? 수정이 많아?**
5. **범위 쿼리? 누적?**

이 질문들이 곧 자료구조 선택임.

---

## 1️⃣ “계속 최댓값 / 최솟값만 필요”

👉 **priority_queue**

### 문제 신호

- “가장 큰 값부터”
- “가장 작은 작업”
- “우선 처리”
- “매번 최고/최저”

### 바로 떠올려야 할 구조

```cpp
priority_queue<int> pq;// 최대
priority_queue<int, vector<int>, greater<int>> pq;// 최소
```

📌 예시

- 카드 합치기
- 강의실 배정
- 작업 스케줄링

---

## 2️⃣ “먼저 들어온 것부터 / 순서대로 처리”

👉 **queue**

### 문제 신호

- “순서대로”
- “차례대로”
- “대기열”
- “확산 / 전파”

📌 거의 무조건

- BFS
- 시뮬레이션

---

## 3️⃣ “최근 것부터 처리 / 되돌리기”

👉 **stack**

### 문제 신호

- “되돌아가기”
- “이전 상태”
- “괄호 검사”
- “LIFO”

📌 예시

- 괄호 문제
- 문자열 폭발
- DFS 재귀 대체

---

## 4️⃣ “존재 여부만 빠르게 확인”

👉 **unordered_set / unordered_map**

### 문제 신호

- “이미 나온 적 있는지”
- “중복 체크”
- “방문 여부”
- “빠른 조회”

📌 조건

- 순서 필요 ❌
- 빠른 탐색 ⭕

```cpp
unordered_set<int> s;
unordered_map<string,int> mp;
```

⚠️ 단, 해시 충돌 위험 있으면 `set/map`

---

## 5️⃣ “정렬된 상태 유지 + 범위 탐색”

👉 **set / map**

### 문제 신호

- “작은 순부터”
- “이상/이하”
- “구간”
- “정렬 유지”

📌 예시

- lower_bound / upper_bound 필요
- 자동 정렬

---

## 6️⃣ “인덱스로 접근 많음 / 순회 위주”

👉 **vector**

### 문제 신호

- “배열처럼”
- “순차 접근”
- “정렬 후 처리”

📌 가장 기본 & 가장 빠름

👉 **웬만하면 vector부터 의심**

---

## 7️⃣ “카운트 / 빈도”

👉 **map / unordered_map**

### 문제 신호

- “몇 번 나오는지”
- “빈도수”
- “통계”

📌 판단 기준

- 입력 크기 큼 → `unordered_map`
- 정렬된 출력 필요 → `map`

---

## 8️⃣ “최단거리 / 최소 횟수”

👉 **BFS + queue + dist 배열**

### 문제 신호

- “최소”
- “최단”
- “가장 빠르게”
- “몇 번 만에”

📌 거의 공식

```cpp
queue<좌표/노드>
dist[] 또는 배열
```

---

## 9️⃣ “모든 경우 시도 + 되돌리기”

👉 **백트래킹 (DFS + visited)**

### 문제 신호

- “모든 경우”
- “가능한 조합”
- “선택/취소 반복”

📌 자료구조

- vector (현재 상태)
- visited 배열

---

## 🔟 “누적 합 / 구간 합”

👉 **prefix sum / DP 배열**

### 문제 신호

- “구간 합”
- “누적”
- “한 번 계산 후 여러 쿼리”

📌 절대 반복문 중첩하지 말 것

---

# 🎯 실전 훈련 방법 (이게 핵심)

### 🔹 Step 1

문제 읽고 **코딩하지 말고**

👉 “자료구조 뭐 쓰지?”를 먼저 말로 답해보기

### 🔹 Step 2

이 문장 완성 연습

> “이 문제는 ○○ 때문에 ○○ 자료구조를 쓴다”
> 

### 🔹 Step 3

틀렸다면?

- 알고리즘 ❌
- **자료구조 선택이 틀렸는지 먼저 의심**
