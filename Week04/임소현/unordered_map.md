# unordered_map

# ğŸ”¹ unordered_map ì™„ì „ ì •ë¦¬ (ì½”ë”©í…ŒìŠ¤íŠ¸ ê¸°ì¤€)

## 1ï¸âƒ£ unordered_mapì´ ë­ì•¼?

ğŸ‘‰ **í•´ì‹œ í…Œì´ë¸” ê¸°ë°˜ map**

- **í‚¤ â†’ ê°’** ì €ì¥
- **ì •ë ¬ âŒ**
- í‰ê·  ì‹œê°„ë³µì¡ë„ **O(1)**

```cpp
#include <unordered_map>

unordered_map<string,int> mp;
```

---

## 2ï¸âƒ£ map vs unordered_map ì°¨ì´

| êµ¬ë¶„ | map | unordered_map |
| --- | --- | --- |
| ë‚´ë¶€ êµ¬ì¡° | Red-Black Tree | Hash Table |
| ì •ë ¬ | O (ìë™ ì •ë ¬) | âŒ |
| íƒìƒ‰ | O(log N) | í‰ê·  O(1) |
| ìˆœì„œ ë³´ì¥ | í‚¤ ìˆœì„œ | ëœë¤ |
| ì½”í…Œ ì²´ê° ì†ë„ | ë³´í†µ | ë§¤ìš° ë¹ ë¦„ |

ğŸ“Œ **ì •ë ¬ í•„ìš” ì—†ìœ¼ë©´ ë¬´ì¡°ê±´ unordered_map ë¨¼ì € ì˜ì‹¬**

---

## 3ï¸âƒ£ ì–¸ì œ unordered_map ì¨ì•¼ í•´?

### âœ… ì´ëŸ° ë¬¸ì œì—ì„œ ë°”ë¡œ ë– ì˜¬ë ¤ì•¼ í•¨

- ë¹ˆë„ ìˆ˜ ì„¸ê¸°
- ì¡´ì¬ ì—¬ë¶€ ë¹ ë¥¸ ì²´í¬
- ë¬¸ìì—´ í‚¤
- ìˆ«ì ë²”ìœ„ê°€ ë§¤ìš° í´ ë•Œ

ğŸ“Œ ë¬¸ì œ ì‹ í˜¸

- â€œëª‡ ë²ˆ ë“±ì¥â€
- â€œì´ë¯¸ ë‚˜ì˜¨ ì  ìˆëŠ”ì§€â€
- â€œì¤‘ë³µ ì œê±°â€
- â€œID / ì´ë¦„ / ë¬¸ìì—´â€

---

## 4ï¸âƒ£ ê¸°ë³¸ ì‚¬ìš©ë²• (í•„ìˆ˜)

### ğŸ”¹ ì‚½ì… / ì ‘ê·¼

```cpp
mp["apple"] =3;
mp["banana"]++;
```

âš ï¸ ì—†ëŠ” í‚¤ ì ‘ê·¼í•˜ë©´ **ìë™ ìƒì„±ë¨**

```cpp
mp["ghost"]++; // default: ê°’ 0ì—ì„œ ì‹œì‘
```

---

### ğŸ”¹ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (ì¤‘ìš”)

```cpp
if (mp.find("apple") != mp.end()) {
	// ì¡´ì¬
}
```

**âŒ ì´ê±° ìœ„í—˜**

```cpp
if (mp["apple"]) // ì—†ëŠ” í‚¤ë©´ ìƒì„±ë¨
```

---

### ğŸ”¹ ìˆœíšŒ

```cpp
for (auto &p : mp) {
    cout << p.first << " " << p.second << '\n';
}
```

ğŸ‘‰ ìˆœì„œ **ë³´ì¥ ì•ˆ ë¨**

---

## 5ï¸âƒ£ ì‹œê°„ë³µì¡ë„ ì •ë¦¬

| ì—°ì‚° | í‰ê·  | ìµœì•… |
| --- | --- | --- |
| ì‚½ì… | O(1) | O(N) |
| íƒìƒ‰ | O(1) | O(N) |
| ì‚­ì œ | O(1) | O(N) |

ğŸ“Œ **ì½”í…ŒëŠ” í‰ê· ë§Œ ë¯¿ì–´ë„ OK**

ğŸ“Œ ë‹¨, ì…ë ¥ì´ ì•…ì˜ì ì´ë©´ mapì´ ì•ˆì „

---

## 6ï¸âƒ£ unordered_map ì“°ë‹¤ í„°ì§€ëŠ” ì´ìœ  TOP

### âŒ 1. ì •ë ¬ëœ ì¶œë ¥ ìš”êµ¬

```cpp
unordered_map â†’ ì¶œë ¥ ìˆœì„œ ëœë¤ â†’ ì˜¤ë‹µ
```

âœ” í•´ê²°: `map` ì‚¬ìš© or vectorë¡œ ì˜®ê²¨ì„œ ì •ë ¬

---

### âŒ 2. find ëŒ€ì‹  [] ì‚¬ìš©

```cpp
mp[x]// ì¡´ì¬ í™•ì¸ìš© âŒ ->  map ì“¸ ë•Œ ëŠ˜ ì¡°ì‹¬!!!!!
```

â†’ **ì“¸ë°ì—†ëŠ” í‚¤ ìƒì„± â†’ ë©”ëª¨ë¦¬ í­ë°œ**

---

### âŒ 3. í•´ì‹œ ì¶©ëŒ (ê³ ê¸‰)

- int, stringì€ ì•ˆì „
- pair, structëŠ” ì§ì ‘ hash ì •ì˜ í•„ìš”

---

## 7ï¸âƒ£ unordered_map + pair í‚¤ ì“°ëŠ” ë²• (ì¤‘ê¸‰)

```cpp
unordered_map <pair<int,int>,int> mp;// âŒ ì—ëŸ¬
```

âœ” í•´ê²°

```cpp
struct PairHash {
	size_t operator()(const pair<int,int>& p) const {
		return hash<int>()(p.first) ^hash<int>()(p.second);
  }
};

unordered_map<pair<int,int>,int, PairHash> mp;
```

ğŸ“Œ BFS ìƒíƒœ ì €ì¥í•  ë•Œ ìì£¼ ì”€

---

## 8ï¸âƒ£ ì½”í…Œ ì‹¤ì „ íŒ¨í„´ 5ê°€ì§€

### ğŸ”¹ 1. ë¹ˆë„ ì¹´ìš´íŠ¸

```cpp
unordered_map<int,int> cnt;
for (int x : v) cnt[x]++;
```

---

### ğŸ”¹ 2. ì¤‘ë³µ ì²´í¬

```cpp
unordered_map<int,bool> seen;
if (seen.find(x) != seen.end()) ...
```

---

### ğŸ”¹ 3. ì¸ë±ìŠ¤ ë§¤í•‘

```cpp
unordered_map<string,int> id;
id[name] = idx++;
```

---

### ğŸ”¹ 4. ì¢Œí‘œ ì••ì¶• ì „ ë‹¨ê³„

- ì¢Œí‘œ ì••ì¶•: ë„ˆë¬´ ê°’ì´ í° ì¢Œí‘œâ†’ ì¸ë±ìŠ¤ë¡œ ëª» ì“°ëŠ” ê²½ìš° ë°œìƒ â†’ ê°’ì˜ í¬ê¸° ê´€ê³„ë§Œ ìœ ì§€í•˜ë©´ì„œ ë‹¤ì‹œ ë²ˆí˜¸ë¥¼ ë¶™ì´ëŠ” ê²ƒ

```cpp
unordered_map<int,int> mp;
```

---

### ğŸ”¹ 5. ë¹ ë¥¸ ìƒíƒœ ê¸°ë¡ (DP/BFS)

```cpp
unordered_map<string,int> dist;
```

---

## 9ï¸âƒ£ unordered_map ì„±ëŠ¥ íŒ (ì§„ì§œ ì¤‘ìš”)

### ğŸ”¥ reserve() ê¼­ ì¨ë¼

```cpp
mp.reserve(200000);
```

ğŸ“Œ ë¦¬í•´ì‹± ë°©ì§€ â†’ ì†ë„ + ë©”ëª¨ë¦¬ ì•ˆì •

---

### ğŸ”¥ max_load_factor ì¤„ì´ê¸° (ì„ íƒ)

```cpp
mp.max_load_factor(0.7);
```

ğŸ‘‰ ëœ»:

> load_factorê°€ 0.7ì„ ë„˜ê¸°ê¸° ì „ì— ìë™ìœ¼ë¡œ rehash í•˜ê² ë‹¤
> 

ì¦‰,

- ì›ì†Œê°€ ëŠ˜ì–´ë‚˜ì„œ
- `(size / bucket_count) > 0.7` ì´ ë˜ë©´
    
    â¡ï¸ **ë²„í‚· ìˆ˜ë¥¼ ëŠ˜ë¦¬ê³  ì¬ë°°ì¹˜**
    

---

## ğŸ”Ÿ í•œ ì¤„ ìš”ì•½

> unordered_mapì€ 
â€œì •ë ¬ í•„ìš” ì—†ëŠ” ë¹ ë¥¸ ì¡°íšŒ/ì¹´ìš´íŠ¸â€ì˜ ìµœê°•ìë‹¤
í•˜ì§€ë§Œ [] ë‚¨ìš©í•˜ë©´ ë°”ë¡œ í„°ì§„ë‹¤
>
